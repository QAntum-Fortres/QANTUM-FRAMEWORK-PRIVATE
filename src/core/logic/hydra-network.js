#!/usr/bin/env node

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  ğŸ² QANTUM PRIME v28.2.2 - HYDRA NETWORK                                     â•‘
 * â•‘  Self-Healing Proxy Rotation | Circuit Breaker | Connection Pooling          â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘                                                                              â•‘
 * â•‘  ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:                                                                â•‘
 * â•‘  â€¢ HydraNode: Ğ•Ğ´Ğ¸Ğ½Ğ¸Ñ‡Ğ½Ğ° "Ğ³Ğ»Ğ°Ğ²Ğ°" Ñ Keep-Alive Agent                            â•‘
 * â•‘  â€¢ HydraNetwork: ĞÑ€ĞºĞµÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ½Ğ° Ğ²ÑĞ¸Ñ‡ĞºĞ¸ Ğ³Ğ»Ğ°Ğ²Ğ¸                                 â•‘
 * â•‘  â€¢ Circuit Breaker: ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ¸Ğ·ĞºĞ»ÑÑ‡Ğ²Ğ°Ğ½Ğµ Ğ½Ğ° Ğ¼ÑŠÑ€Ñ‚Ğ²Ğ¸ Ğ¿Ñ€Ğ¾ĞºÑĞ¸Ñ‚Ğ°               â•‘
 * â•‘  â€¢ Self-Healing: Ğ’ÑŠĞ·ĞºÑ€ĞµÑÑĞ²Ğ°Ğ½Ğµ ÑĞ»ĞµĞ´ 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ¸ Ğ½Ğ°ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ                        â•‘
 * â•‘                                                                              â•‘
 * â•‘  Ğ—Ğ° Ğ±Ğ¾Ñ€ÑĞ°Ñ‚Ğ°: 1000 Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ğ¸ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»Ğ¸ Ğ¾Ñ‚ Ñ†ÑĞ» ÑĞ²ÑÑ‚! ğŸŒ                       â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

'use strict';

const { HttpsProxyAgent } = require('hpagent');
const v8 = require('v8');
v8.setFlagsFromString('--no-lazy');

// Dynamic import Ğ·Ğ° ESM Ğ¼Ğ¾Ğ´ÑƒĞ»
let gotScraping;
const loadGotScraping = async () => {
    if (!gotScraping) {
        const module = await import('got-scraping');
        gotScraping = module.gotScraping;
    }
    return gotScraping;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROXY CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ğ’ Ñ€ĞµĞ°Ğ»Ğ½Ğ° ÑÑ€ĞµĞ´Ğ°: Ğ·Ğ°Ñ€ĞµĞ¶Ğ´Ğ° ÑĞµ Ğ¾Ñ‚ Ñ„Ğ°Ğ¹Ğ» Ğ¸Ğ»Ğ¸ API
const MOCK_PROXY_LIST = [
    // USA
    'http://user:pass@185.199.108.153:8080',
    'http://user:pass@185.199.109.153:8080',
    'http://user:pass@185.199.110.153:8080',
    // Europe
    'http://user:pass@104.21.56.128:8080',
    'http://user:pass@172.67.182.31:8080',
    'http://user:pass@213.232.87.46:8080',
    // Asia
    'http://user:pass@203.104.128.47:8080',
    'http://user:pass@103.152.220.44:8080',
    'http://user:pass@139.99.96.72:8080',
    // ... Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ¸ ÑĞ¸ 10,000 Ñ€ĞµĞ´Ğ° Ñ‚ÑƒĞº
];

// JA3 Browser Profiles
const BROWSER_PROFILES = [
    { name: 'chrome', minVersion: 120, maxVersion: 121 },
    { name: 'firefox', minVersion: 120, maxVersion: 122 },
    { name: 'safari', minVersion: 17, maxVersion: 17 },
    { name: 'edge', minVersion: 119, maxVersion: 120 }
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RING BUFFER (Ğ·Ğ° Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RingBuffer {
    constructor(size = 10000) {
        this.buffer = new Array(size);
        this.size = size;
        this.write = 0;
        this.read = 0;
        this.count = 0;
        this.overflows = 0;
    }
    
    push(item) {
        if (this.count >= this.size) {
            this.read = (this.read + 1) % this.size;
            this.count--;
            this.overflows++;
        }
        this.buffer[this.write] = item;
        this.write = (this.write + 1) % this.size;
        this.count++;
    }
    
    pop() {
        if (this.count === 0) return null;
        const item = this.buffer[this.read];
        this.read = (this.read + 1) % this.size;
        this.count--;
        return item;
    }
    
    isEmpty() { return this.count === 0; }
    isFull() { return this.count >= this.size; }
    getLoad() { return ((this.count / this.size) * 100).toFixed(1); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HYDRA NODE - Ğ•Ğ´Ğ¸Ğ½Ğ¸Ñ‡Ğ½Ğ° "Ğ³Ğ»Ğ°Ğ²Ğ°"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HydraNode {
    constructor(proxyUrl, id) {
        this.id = id;
        this.url = proxyUrl;
        this.failures = 0;
        this.successes = 0;
        this.isDead = false;
        this.deadUntil = 0;
        this.totalLatency = 0;
        this.requestCount = 0;
        
        // Ğ¡ÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ¼Ğµ Ğ°Ğ³ĞµĞ½Ñ‚Ğ° Ğ’Ğ•Ğ”ĞĞªĞ– Ğ¸ Ğ³Ğ¾ Ğ¿Ñ€ĞµĞ¸Ğ·Ğ¿Ğ¾Ğ»Ğ·Ğ²Ğ°Ğ¼Ğµ (Keep-Alive)
        this.agent = new HttpsProxyAgent({
            keepAlive: true,
            keepAliveMsecs: 1000,      // Ğ”Ñ€ÑŠĞ¶ Ğ²Ñ€ÑŠĞ·ĞºĞ°Ñ‚Ğ° Ğ¾Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ° 1 ÑĞµĞº
            maxSockets: 256,            // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ Ğ¿Ğ°Ñ€Ğ°Ğ»ĞµĞ»Ğ½Ğ¸ Ğ²Ñ€ÑŠĞ·ĞºĞ¸
            maxFreeSockets: 256,        // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¸ ÑĞ¾ĞºĞµÑ‚Ğ¸
            scheduling: 'lifo',         // Last-In-First-Out Ğ·Ğ° hot connections
            proxy: proxyUrl,
            timeout: 5000
        });
        
        // Parse proxy URL Ğ·Ğ° Ğ»Ğ¾Ğ³Ğ¾Ğ²Ğµ
        try {
            const parsed = new URL(proxyUrl);
            this.displayName = `${parsed.hostname}:${parsed.port}`;
        } catch {
            this.displayName = `Node-${id}`;
        }
    }

    /**
     * ĞœĞ°Ñ€ĞºĞ¸Ñ€Ğ° Ğ³Ñ€ĞµÑˆĞºĞ°. ĞŸÑ€Ğ¸ 3 Ğ³Ñ€ĞµÑˆĞºĞ¸ -> Circuit Breaker Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ
     */
    markFailure() {
        this.failures++;
        if (this.failures >= 3) {
            this.isDead = true;
            this.deadUntil = Date.now() + 300000; // 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ¸ Ğ½Ğ°ĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ
            console.warn(`ğŸ’€ [Circuit Breaker] Node DEAD: ${this.displayName} (${this.failures} failures)`);
            return true;
        }
        return false;
    }

    /**
     * ĞœĞ°Ñ€ĞºĞ¸Ñ€Ğ° ÑƒÑĞ¿ĞµÑ…
     */
    markSuccess(latencyMs) {
        this.successes++;
        this.totalLatency += latencyMs;
        this.requestCount++;
        // ĞĞ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ¼Ğµ failures Ğ¿Ñ€Ğ¸ ÑƒÑĞ¿ĞµÑ… (self-healing)
        if (this.failures > 0) this.failures--;
    }

    /**
     * ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ²Ğ° Ğ´Ğ°Ğ»Ğ¸ Ğ¼Ğ¾Ğ¶Ğµ Ğ´Ğ° ÑĞµ Ğ²ÑŠĞ·ĞºÑ€ĞµÑĞ¸
     */
    tryRevive() {
        if (this.isDead && Date.now() > this.deadUntil) {
            this.isDead = false;
            this.failures = 0;
            console.log(`âœ¨ [Circuit Breaker] Node REVIVED: ${this.displayName}`);
            return true;
        }
        return false;
    }

    /**
     * Ğ¡Ñ€ĞµĞ´Ğ½Ğ° Ğ»Ğ°Ñ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚
     */
    getAvgLatency() {
        return this.requestCount > 0 
            ? (this.totalLatency / this.requestCount).toFixed(2) 
            : 0;
    }

    /**
     * Success rate
     */
    getSuccessRate() {
        const total = this.successes + this.failures;
        return total > 0 ? ((this.successes / total) * 100).toFixed(1) : 100;
    }

    /**
     * Destroy agent
     */
    destroy() {
        this.agent.destroy();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HYDRA NETWORK - ĞÑ€ĞºĞµÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HydraNetwork {
    constructor(ringBuffer, options = {}) {
        this.outputBuffer = ringBuffer || new RingBuffer(10000);
        this.nodes = [];
        this.currentIndex = 0;
        this.isRunning = false;
        this.attackInterval = null;
        
        // Statistics
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            circuitBreakerTrips: 0,
            revivals: 0
        };
        
        // ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
        this.config = {
            timeout: options.timeout || 800,
            maxFailures: options.maxFailures || 3,
            deadTime: options.deadTime || 300000,  // 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ¸
            proxyList: options.proxyList || MOCK_PROXY_LIST
        };
        
        // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° "Ğ³Ğ»Ğ°Ğ²Ğ¸Ñ‚Ğµ" Ğ½Ğ° Ğ¥Ğ¸Ğ´Ñ€Ğ°Ñ‚Ğ°
        console.log(`\nğŸ² Hydra Network: Initializing ${this.config.proxyList.length} heads...`);
        this.config.proxyList.forEach((url, i) => {
            this.nodes.push(new HydraNode(url, i));
        });
        console.log(`ğŸ² Hydra Network: Ready with ${this.nodes.length} nodes\n`);
    }

    /**
     * Round-Robin selection Ñ Circuit Breaker check
     */
    getNextNode() {
        let attempts = 0;
        
        while (attempts < this.nodes.length) {
            const node = this.nodes[this.currentIndex];
            this.currentIndex = (this.currentIndex + 1) % this.nodes.length;

            // ĞĞºĞ¾ Ğµ Ğ¼ÑŠÑ€Ñ‚ÑŠĞ², Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸ Ğ´Ğ°Ğ»Ğ¸ Ğ¼Ğ¾Ğ¶Ğµ Ğ´Ğ° ÑĞµ Ğ²ÑŠĞ·ĞºÑ€ĞµÑĞ¸
            if (node.isDead) {
                if (node.tryRevive()) {
                    this.stats.revivals++;
                    return node;
                }
                attempts++;
                continue;
            }
            
            return node;
        }
        
        throw new Error("âŒ HYDRA COLLAPSE: All heads are dead! Network failure.");
    }

    /**
     * Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ° ÑĞ»ÑƒÑ‡Ğ°ĞµĞ½ browser profile Ğ·Ğ° JA3 fingerprint
     */
    getRandomBrowserProfile() {
        const browser = BROWSER_PROFILES[Math.floor(Math.random() * BROWSER_PROFILES.length)];
        return {
            browsers: [browser],
            devices: ['desktop'],
            locales: ['en-US', 'en-GB', 'de-DE'][Math.floor(Math.random() * 3)],
        };
    }

    /**
     * Fetch market data Ğ¿Ñ€ĞµĞ· Hydra Node
     */
    async fetchMarketData(symbol) {
        const got = await loadGotScraping();
        let node;
        
        try {
            node = this.getNextNode();
            this.stats.totalRequests++;
            
            const start = process.hrtime.bigint();

            const response = await got({
                url: `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`,
                agent: { https: node.agent },
                responseType: 'json',
                retry: { limit: 0 },           // Ğ‘ĞµĞ· retry - HFT speed
                timeout: { request: this.config.timeout },
                headerGeneratorOptions: this.getRandomBrowserProfile(),
                http2: true
            });

            const end = process.hrtime.bigint();
            const latencyMs = Number(end - start) / 1_000_000;

            // Ğ£ÑĞ¿ĞµÑ…!
            node.markSuccess(latencyMs);
            this.stats.successfulRequests++;

            // ĞŸÑ€Ğ°Ñ‰Ğ°Ğ¼Ğµ ĞºÑŠĞ¼ Ring Buffer
            const marketData = {
                symbol: symbol,
                price: parseFloat(response.body.price),
                timestamp: Date.now(),
                latency: latencyMs,
                nodeId: node.id,
                browser: this.getRandomBrowserProfile().browsers[0].name
            };
            
            this.outputBuffer.push(marketData);
            return { success: true, data: marketData };

        } catch (error) {
            this.stats.failedRequests++;
            
            if (node) {
                const tripped = node.markFailure();
                if (tripped) this.stats.circuitBreakerTrips++;
            }
            
            return { success: false, error: error.message };
        }
    }

    /**
     * Batch fetch - Ğ¿Ğ°Ñ€Ğ°Ğ»ĞµĞ»Ğ½Ğ¸ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¿Ñ€ĞµĞ· Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ğ¸ nodes
     */
    async fetchBatch(symbols, concurrency = 5) {
        const results = [];
        
        for (let i = 0; i < symbols.length; i += concurrency) {
            const batch = symbols.slice(i, i + concurrency);
            const promises = batch.map(sym => this.fetchMarketData(sym));
            const batchResults = await Promise.all(promises);
            results.push(...batchResults);
        }
        
        return results;
    }

    /**
     * Ğ¡Ñ‚Ğ°Ñ€Ñ‚Ğ¸Ñ€Ğ° High-Frequency Polling Ğ°Ñ‚Ğ°ĞºĞ°
     */
    startAttack(symbol, ratePerSec = 10) {
        if (this.isRunning) {
            console.warn('âš ï¸ Attack already running!');
            return;
        }
        
        this.isRunning = true;
        const interval = Math.max(1, Math.floor(1000 / ratePerSec));
        
        console.log(`\nğŸš€ HYDRA ATTACK STARTED`);
        console.log(`   Target: ${symbol}`);
        console.log(`   Rate: ${ratePerSec} req/sec (every ${interval}ms)`);
        console.log(`   Active Nodes: ${this.getAliveNodes().length}/${this.nodes.length}\n`);
        
        this.attackInterval = setInterval(() => {
            this.fetchMarketData(symbol);
        }, interval);
        
        return this.attackInterval;
    }

    /**
     * Ğ¡Ğ¿Ğ¸Ñ€Ğ° Ğ°Ñ‚Ğ°ĞºĞ°Ñ‚Ğ°
     */
    stopAttack() {
        if (this.attackInterval) {
            clearInterval(this.attackInterval);
            this.attackInterval = null;
            this.isRunning = false;
            console.log('\nğŸ›‘ HYDRA ATTACK STOPPED\n');
        }
    }

    /**
     * Ğ’Ñ€ÑŠÑ‰Ğ° Ğ¶Ğ¸Ğ²Ğ¸Ñ‚Ğµ nodes
     */
    getAliveNodes() {
        return this.nodes.filter(n => !n.isDead);
    }

    /**
     * Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
     */
    getStats() {
        const aliveNodes = this.getAliveNodes();
        const avgLatency = aliveNodes.reduce((sum, n) => sum + parseFloat(n.getAvgLatency()), 0) / aliveNodes.length || 0;
        
        return {
            totalRequests: this.stats.totalRequests,
            successful: this.stats.successfulRequests,
            failed: this.stats.failedRequests,
            successRate: this.stats.totalRequests > 0 
                ? ((this.stats.successfulRequests / this.stats.totalRequests) * 100).toFixed(1) + '%'
                : '100%',
            avgLatency: avgLatency.toFixed(2) + 'ms',
            aliveNodes: aliveNodes.length,
            deadNodes: this.nodes.length - aliveNodes.length,
            circuitBreakerTrips: this.stats.circuitBreakerTrips,
            revivals: this.stats.revivals,
            bufferLoad: this.outputBuffer.getLoad() + '%'
        };
    }

    /**
     * Node health report
     */
    getNodeHealth() {
        return this.nodes.map(n => ({
            id: n.id,
            name: n.displayName,
            alive: !n.isDead,
            successes: n.successes,
            failures: n.failures,
            avgLatency: n.getAvgLatency() + 'ms',
            successRate: n.getSuccessRate() + '%'
        }));
    }

    /**
     * Cleanup
     */
    destroy() {
        this.stopAttack();
        this.nodes.forEach(n => n.destroy());
        console.log('ğŸ² Hydra Network destroyed. All connections closed.');
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ATOMIC ENGINE (Consumer)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AtomicEngine {
    constructor(inputBuffer) {
        this.inputBuffer = inputBuffer;
        this.isRunning = false;
        this.decisions = { buy: 0, sell: 0, hold: 0 };
        this.latencies = [];
        this.lastPrices = new Map();
    }

    /**
     * Trading decision logic - Momentum Scalping
     */
    makeDecision(data) {
        const start = process.hrtime.bigint();
        
        const lastPrice = this.lastPrices.get(data.symbol) || data.price;
        const priceChange = ((data.price - lastPrice) / lastPrice) * 100;
        this.lastPrices.set(data.symbol, data.price);
        
        let action = 'HOLD';
        let confidence = 50;
        
        // Momentum strategy
        if (priceChange < -0.01) {
            action = 'BUY';  // Dip buying
            confidence = Math.min(95, 60 + Math.abs(priceChange) * 1000);
        } else if (priceChange > 0.01) {
            action = 'SELL'; // Take profit
            confidence = Math.min(95, 60 + priceChange * 1000);
        }
        
        const end = process.hrtime.bigint();
        const latencyUs = Number(end - start) / 1000;
        this.latencies.push(latencyUs);
        
        this.decisions[action.toLowerCase()]++;
        
        return {
            action,
            confidence: confidence.toFixed(1),
            symbol: data.symbol,
            price: data.price,
            priceChange: priceChange.toFixed(4),
            latencyUs: latencyUs.toFixed(3)
        };
    }

    /**
     * Start consuming from buffer
     */
    start(onDecision) {
        this.isRunning = true;
        
        const consume = () => {
            if (!this.isRunning) return;
            
            let processed = 0;
            while (!this.inputBuffer.isEmpty() && processed < 100) {
                const data = this.inputBuffer.pop();
                if (data) {
                    const decision = this.makeDecision(data);
                    if (onDecision && decision.action !== 'HOLD') {
                        onDecision(decision);
                    }
                }
                processed++;
            }
            
            setImmediate(consume);
        };
        
        consume();
    }

    stop() {
        this.isRunning = false;
    }

    getStats() {
        const avgLatency = this.latencies.length > 0
            ? (this.latencies.reduce((a, b) => a + b, 0) / this.latencies.length).toFixed(3)
            : 0;
        
        return {
            totalDecisions: this.decisions.buy + this.decisions.sell + this.decisions.hold,
            buy: this.decisions.buy,
            sell: this.decisions.sell,
            hold: this.decisions.hold,
            avgLatencyUs: avgLatency
        };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEMO MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HydraDemo {
    constructor(ringBuffer) {
        this.outputBuffer = ringBuffer || new RingBuffer(10000);
        this.nodes = [
            { id: 0, ip: '45.12.134.72', country: 'US', city: 'NYC', alive: true, failures: 0 },
            { id: 1, ip: '185.199.108.153', country: 'DE', city: 'Frankfurt', alive: true, failures: 0 },
            { id: 2, ip: '104.21.56.128', country: 'SG', city: 'Singapore', alive: true, failures: 0 },
            { id: 3, ip: '172.67.182.31', country: 'UK', city: 'London', alive: true, failures: 0 },
            { id: 4, ip: '203.104.128.47', country: 'JP', city: 'Tokyo', alive: true, failures: 0 },
        ];
        this.currentIndex = 0;
        this.stats = { total: 0, success: 0, failed: 0 };
        this.browsers = ['Chrome 121', 'Firefox 122', 'Safari 17', 'Edge 120'];
    }

    getNextNode() {
        // Ğ¡Ğ¸Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ° Circuit Breaker with auto-revive
        let attempts = 0;
        while (attempts < this.nodes.length) {
            const node = this.nodes[this.currentIndex];
            this.currentIndex = (this.currentIndex + 1) % this.nodes.length;
            if (node.alive) return node;
            attempts++;
        }
        // Auto-revive all nodes when all are dead (demo only)
        console.log('ğŸ”„ [Demo] All nodes dead - auto-reviving...');
        this.nodes.forEach(n => { n.alive = true; n.failures = 0; });
        return this.nodes[0];
    }

    async fetchMarketData(symbol) {
        const node = this.getNextNode();
        const browser = this.browsers[Math.floor(Math.random() * this.browsers.length)];
        
        // Ğ¡Ğ¸Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ°Ğ½Ğ° Ğ»Ğ°Ñ‚ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚
        const latencyMs = 5 + Math.random() * 45;
        await new Promise(r => setTimeout(r, latencyMs));
        
        // Ğ¡Ğ¸Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ°Ğ½Ğ° Ñ†ĞµĞ½Ğ°
        const basePrice = { BTCUSDT: 45000, ETHUSDT: 2500, SOLUSDT: 105 }[symbol] || 100;
        const price = basePrice + (Math.random() - 0.5) * basePrice * 0.002;
        
        // Ğ¡Ğ¸Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ° ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ° Ğ³Ñ€ĞµÑˆĞºĞ° (5% chance)
        if (Math.random() < 0.05) {
            node.failures++;
            if (node.failures >= 3) {
                node.alive = false;
                console.warn(`ğŸ’€ [Demo] Node ${node.ip} marked DEAD`);
            }
            this.stats.failed++;
            return { success: false, error: 'Simulated timeout' };
        }
        
        this.stats.total++;
        this.stats.success++;
        
        const data = {
            symbol,
            price,
            timestamp: Date.now(),
            latency: latencyMs,
            nodeId: node.id,
            browser,
            proxy: `${node.ip} (${node.country})`
        };
        
        this.outputBuffer.push(data);
        return { success: true, data };
    }

    getStats() {
        return {
            total: this.stats.total,
            success: this.stats.success,
            failed: this.stats.failed,
            aliveNodes: this.nodes.filter(n => n.alive).length,
            bufferLoad: this.outputBuffer.getLoad() + '%'
        };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN - INTEGRATED DEMO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(async () => {
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ² QANTUM PRIME v28.2.2 - HYDRA NETWORK + ATOMIC ENGINE                     â•‘
â•‘  Self-Healing Proxy Rotation | Circuit Breaker | Sub-Î¼s Decision             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                              â•‘
â•‘  Components:                                                                 â•‘
â•‘  â€¢ ğŸ² Hydra Network: Multi-head proxy rotator                                â•‘
â•‘  â€¢ ğŸ“¦ Ring Buffer: O(1) Zero-GC queue                                        â•‘
â•‘  â€¢ âš¡ Atomic Engine: Sub-microsecond decision making                         â•‘
â•‘  â€¢ ğŸ”’ Circuit Breaker: Auto-disable failing nodes                            â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

    // Ğ¡ÑŠĞ·Ğ´Ğ°Ğ²Ğ°Ğ¼Ğµ ÑĞ¿Ğ¾Ğ´ĞµĞ»ĞµĞ½ Ring Buffer
    const sharedBuffer = new RingBuffer(10000);
    
    // Demo mode (Ğ±ĞµĞ· Ñ€ĞµĞ°Ğ»Ğ½Ğ¸ Ğ¿Ñ€Ğ¾ĞºÑĞ¸Ñ‚Ğ°)
    console.log('ğŸ® Running in DEMO MODE (simulated proxies)\n');
    
    const hydra = new HydraDemo(sharedBuffer);
    const engine = new AtomicEngine(sharedBuffer);
    
    // Start Atomic Engine consumer
    console.log('âš¡ Starting Atomic Engine...');
    engine.start((decision) => {
        if (Math.random() < 0.3) { // Sample 30% Ğ·Ğ° Ğ»Ğ¾Ğ³Ğ°
            const icon = decision.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
            console.log(`${icon} ${decision.action} ${decision.symbol} @ $${decision.price.toFixed(2)} | Conf: ${decision.confidence}% | ${decision.latencyUs}Î¼s`);
        }
    });
    
    // Simulate Hydra attack
    console.log('ğŸ² Starting Hydra attack simulation...\n');
    
    const symbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'];
    const duration = 5000; // 5 ÑĞµĞºÑƒĞ½Ğ´Ğ¸
    const startTime = Date.now();
    
    const attackLoop = async () => {
        while (Date.now() - startTime < duration) {
            const symbol = symbols[Math.floor(Math.random() * symbols.length)];
            await hydra.fetchMarketData(symbol);
            await new Promise(r => setTimeout(r, 50)); // ~20 req/sec
        }
    };
    
    await attackLoop();
    
    // Stop and report
    engine.stop();
    
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“Š FINAL STATISTICS                                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);

    const hydraStats = hydra.getStats();
    const engineStats = engine.getStats();
    
    console.log(`â•‘                                                                              â•‘
â•‘  ğŸ² HYDRA NETWORK:                                                           â•‘
â•‘     Total Requests: ${String(hydraStats.total).padEnd(10)} | Success: ${String(hydraStats.success).padEnd(10)}             â•‘
â•‘     Failed: ${String(hydraStats.failed).padEnd(10)}        | Alive Nodes: ${String(hydraStats.aliveNodes).padEnd(10)}          â•‘
â•‘     Buffer Load: ${String(hydraStats.bufferLoad).padEnd(10)}                                            â•‘
â•‘                                                                              â•‘
â•‘  âš¡ ATOMIC ENGINE:                                                            â•‘
â•‘     Total Decisions: ${String(engineStats.totalDecisions).padEnd(10)}                                       â•‘
â•‘     BUY: ${String(engineStats.buy).padEnd(6)} | SELL: ${String(engineStats.sell).padEnd(6)} | HOLD: ${String(engineStats.hold).padEnd(10)}        â•‘
â•‘     Avg Latency: ${String(engineStats.avgLatencyUs + 'Î¼s').padEnd(12)} (SUB-MICROSECOND!)                  â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

    console.log(`
ğŸ’¡ Ğ¡Ğ»ĞµĞ´Ğ²Ğ°Ñ‰Ğ° ÑÑ‚ÑŠĞ¿ĞºĞ°: "Ğ ĞªĞ¦Ğ•Ğ¢Ğ•" Ğ½Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ñ‚Ğ°
   
   ĞĞ¿Ñ†Ğ¸Ñ 1: ğŸ“„ PDF Proposal Generator
            ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ°Ğ½Ğµ Ğ½Ğ° Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¾Ğ½ĞµĞ½ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·
   
   ĞĞ¿Ñ†Ğ¸Ñ 2: â›“ï¸  Smart Contract Execution (Web3.js)
            Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ½Ğ¸ DEX Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ (Uniswap/PancakeSwap)
`);

})();

// Export Ğ·Ğ° Ğ¸Ğ·Ğ¿Ğ¾Ğ»Ğ·Ğ²Ğ°Ğ½Ğµ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸
module.exports = { HydraNetwork, HydraNode, RingBuffer, AtomicEngine, HydraDemo };
