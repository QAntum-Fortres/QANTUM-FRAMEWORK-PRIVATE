/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ° FORTRESS INTEGRATION - GATEWAY-FATALITY BRIDGE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * v1.5.0 "The Sovereign Gateway" - Security Fortress Integration
 *
 *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
 *   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 *   â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 *   â•šâ•â•      â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *   MARKET VALUE INCREMENT: +$75,000
 *
 *   Features:
 *   â€¢ Automatic IP Ban after 5 invalid attempts
 *   â€¢ Swarm-wide IP synchronization
 *   â€¢ Attacker profiling & fingerprinting
 *   â€¢ HoneyPot activation on breach attempt
 *   â€¢ Real-time threat intelligence sharing
 *   â€¢ Distributed ban list propagation
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * @module reality/gateway
 * @version 1.5.0
 * @license Commercial - All Rights Reserved
 * @author QANTUM AI Architect
 * @commercial true
 * @marketValue $75,000
 */

import * as crypto from 'crypto';
import { EventEmitter } from 'events';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type ThreatLevel = 'low' | 'medium' | 'high' | 'critical';
export type BanDuration = 'temporary' | 'extended' | 'permanent';
export type AttackType =
  | 'brute_force'
  | 'injection'
  | 'credential_stuffing'
  | 'rate_abuse'
  | 'unknown';

/**
 * Security violation record
 */
export interface SecurityViolation {
  id: string;
  timestamp: number;
  ip: string;
  keyId: string;
  type: AttackType;
  description: string;
  metadata: Record<string, unknown>;
  fingerprint?: string;
}

/**
 * Banned IP record
 */
export interface BannedIP {
  ip: string;
  bannedAt: number;
  expiresAt: number;
  duration: BanDuration;
  reason: string;
  violations: SecurityViolation[];
  swarmSynced: boolean;
  threatLevel: ThreatLevel;
}

/**
 * Attacker profile
 */
export interface AttackerProfile {
  fingerprint: string;
  knownIPs: string[];
  firstSeen: number;
  lastSeen: number;
  totalViolations: number;
  attackTypes: AttackType[];
  threatLevel: ThreatLevel;
  patterns: {
    avgTimeBetweenAttempts: number;
    preferredEndpoints: string[];
    userAgentPatterns: string[];
    geoLocations: string[];
  };
  isHoneyPotTarget: boolean;
}

/**
 * Swarm sync message
 */
export interface SwarmSyncMessage {
  type: 'ban' | 'unban' | 'threat_update' | 'profile_share';
  nodeId: string;
  timestamp: number;
  payload: unknown;
  signature: string;
}

/**
 * Fortress configuration
 */
export interface FortressConfig {
  /** Max invalid attempts before ban */
  maxInvalidAttempts: number;
  /** Time window for counting attempts (ms) */
  attemptWindowMs: number;
  /** Ban durations */
  banDurations: {
    temporary: number; // First offense
    extended: number; // Repeat offense
    permanent: number; // Severe threats
  };
  /** Enable Swarm sync */
  enableSwarmSync: boolean;
  /** Swarm node ID */
  nodeId: string;
  /** Swarm secret for signatures */
  swarmSecret: string;
  /** Enable HoneyPot on breach */
  enableHoneyPot: boolean;
  /** Enable attacker profiling */
  enableProfiling: boolean;
  /** Alert webhook URL */
  alertWebhook?: string;
}

/**
 * Fatality Engine interface (from existing module)
 */
export interface FatalityEngineInterface {
  activateHoneyPot(triggerEvent: string): void;
  collectAttackerProfile(triggerEvent: string): unknown;
  isArmed: boolean;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FORTRESS INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ° FortressIntegration - Gateway-Fatality Security Bridge
 *
 * Connects the Client Gateway to the Fatality Engine for:
 * - Automatic IP banning after threshold violations
 * - Swarm-wide ban synchronization
 * - Attacker profiling and tracking
 * - HoneyPot activation on breach attempts
 *
 * @example
 * ```typescript
 * const fortress = new FortressIntegration({
 *   maxInvalidAttempts: 5,
 *   enableSwarmSync: true
 * });
 *
 * await fortress.initialize();
 *
 * // Report invalid attempt
 * const result = await fortress.reportInvalidAttempt('192.168.1.100', 'LIC_123', 'Invalid API key');
 * if (result.banned) {
 *   console.log(`IP banned for ${result.duration}`);
 * }
 * ```
 */
export class FortressIntegration extends EventEmitter {
  private config: FortressConfig;
  private bannedIPs: Map<string, BannedIP> = new Map();
  private violationHistory: Map<string, SecurityViolation[]> = new Map();
  private attackerProfiles: Map<string, AttackerProfile> = new Map();
  private swarmPeers: Set<string> = new Set();
  private fatalityEngine?: FatalityEngineInterface;
  private isInitialized = false;

  constructor(config?: Partial<FortressConfig>) {
    super();
    this.setMaxListeners(100);

    this.config = {
      maxInvalidAttempts: config?.maxInvalidAttempts ?? 5,
      attemptWindowMs: config?.attemptWindowMs ?? 300000, // 5 minutes
      banDurations: config?.banDurations ?? {
        temporary: 3600000, // 1 hour
        extended: 86400000, // 24 hours
        permanent: -1, // Forever
      },
      enableSwarmSync: config?.enableSwarmSync ?? true,
      nodeId: config?.nodeId ?? `FORTRESS_${crypto.randomBytes(4).toString('hex')}`,
      swarmSecret: config?.swarmSecret ?? crypto.randomBytes(32).toString('hex'),
      enableHoneyPot: config?.enableHoneyPot ?? true,
      enableProfiling: config?.enableProfiling ?? true,
      alertWebhook: config?.alertWebhook,
    };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INITIALIZATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Initialize the Fortress
   */
  async initialize(fatalityEngine?: FatalityEngineInterface): Promise<void> {
    if (this.isInitialized) return;

    this.fatalityEngine = fatalityEngine;

    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                               â•‘
â•‘   ğŸ° FORTRESS INTEGRATION - SECURITY BRIDGE ACTIVE                                            â•‘
â•‘                                                                                               â•‘
â•‘   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘   â”‚  ğŸš« Auto-Ban Threshold  â”‚  ${this.config.maxInvalidAttempts} attempts in ${this.config.attemptWindowMs / 60000} minutes                                 â”‚    â•‘
â•‘   â”‚  ğŸ”— Swarm Sync          â”‚  ${this.config.enableSwarmSync ? 'âœ… ENABLED' : 'âŒ DISABLED'}                                                 â”‚    â•‘
â•‘   â”‚  ğŸ¯ HoneyPot Trigger    â”‚  ${this.config.enableHoneyPot ? 'âœ… ENABLED' : 'âŒ DISABLED'}                                                 â”‚    â•‘
â•‘   â”‚  ğŸ‘¤ Attacker Profiling  â”‚  ${this.config.enableProfiling ? 'âœ… ENABLED' : 'âŒ DISABLED'}                                                 â”‚    â•‘
â•‘   â”‚  ğŸ’€ Fatality Engine     â”‚  ${this.fatalityEngine ? 'âœ… CONNECTED' : 'âš ï¸ NOT CONNECTED'}                                              â”‚    â•‘
â•‘   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                                                               â•‘
â•‘   BAN DURATIONS:                                                                             â•‘
â•‘   â”œâ”€ Temporary (1st offense):   ${this.config.banDurations.temporary / 3600000} hour(s)                                            â•‘
â•‘   â”œâ”€ Extended (repeat):         ${this.config.banDurations.extended / 3600000} hours                                           â•‘
â•‘   â””â”€ Permanent (severe):        âˆ (manual unban required)                                   â•‘
â•‘                                                                                               â•‘
â•‘                       "5 strikes and you're out. No exceptions."                              â•‘
â•‘                                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

    // Start cleanup timer
    this.startCleanupTimer();

    this.isInitialized = true;
    this.emit('initialized', { nodeId: this.config.nodeId });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // VIOLATION TRACKING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Report an invalid authentication attempt
   */
  async reportInvalidAttempt(
    ip: string,
    keyId: string,
    reason: string,
    metadata: Record<string, unknown> = {}
  ): Promise<{ banned: boolean; duration?: string; remaining?: number }> {
    // Check if already banned
    if (await this.isIPBanned(ip)) {
      return { banned: true, duration: 'already_banned' };
    }

    // Create violation record
    const violation: SecurityViolation = {
      id: `VIO_${crypto.randomBytes(8).toString('hex')}`,
      timestamp: Date.now(),
      ip,
      keyId,
      type: this.classifyAttack(reason, metadata),
      description: reason,
      metadata,
      fingerprint: this.generateFingerprint(ip, metadata),
    };

    // Add to history
    const history = this.violationHistory.get(ip) || [];
    history.push(violation);
    this.violationHistory.set(ip, history);

    // Count recent violations
    const windowStart = Date.now() - this.config.attemptWindowMs;
    const recentViolations = history.filter((v) => v.timestamp >= windowStart);

    this.emit('violation_recorded', {
      ip,
      keyId,
      reason,
      count: recentViolations.length,
      threshold: this.config.maxInvalidAttempts,
    });

    // Check threshold
    if (recentViolations.length >= this.config.maxInvalidAttempts) {
      return await this.banIP(
        ip,
        `Exceeded ${this.config.maxInvalidAttempts} invalid attempts: ${reason}`
      );
    }

    return {
      banned: false,
      remaining: this.config.maxInvalidAttempts - recentViolations.length,
    };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IP BANNING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Ban an IP address
   */
  async banIP(
    ip: string,
    reason: string,
    customDuration?: number
  ): Promise<{ banned: boolean; duration: string }> {
    // Determine ban duration based on history
    const previousBan = this.bannedIPs.get(ip);
    let duration: BanDuration;
    let durationMs: number;

    if (previousBan) {
      // Repeat offender - escalate
      if (previousBan.duration === 'temporary') {
        duration = 'extended';
        durationMs = this.config.banDurations.extended;
      } else {
        duration = 'permanent';
        durationMs = -1;
      }
    } else {
      // First offense
      duration = 'temporary';
      durationMs = this.config.banDurations.temporary;
    }

    // Override with custom duration if provided
    if (customDuration !== undefined) {
      durationMs = customDuration;
      duration = customDuration === -1 ? 'permanent' : 'temporary';
    }

    // Calculate threat level
    const violations = this.violationHistory.get(ip) || [];
    const threatLevel = this.calculateThreatLevel(violations);

    // Create ban record
    const ban: BannedIP = {
      ip,
      bannedAt: Date.now(),
      expiresAt: durationMs === -1 ? -1 : Date.now() + durationMs,
      duration,
      reason,
      violations,
      swarmSynced: false,
      threatLevel,
    };

    this.bannedIPs.set(ip, ban);

    // Trigger HoneyPot if threat is high
    if (this.config.enableHoneyPot && threatLevel === 'critical' && this.fatalityEngine) {
      this.fatalityEngine.activateHoneyPot(`IP_BAN_${ip}`);
    }

    // Update attacker profile
    if (this.config.enableProfiling) {
      this.updateAttackerProfile(ip, violations);
    }

    // Sync to Swarm
    if (this.config.enableSwarmSync) {
      await this.syncBanToSwarm(ban);
    }

    // Send alert
    await this.sendAlert('ip_banned', { ip, reason, duration, threatLevel });

    this.emit('ip_banned', { ip, reason, duration, threatLevel, expiresAt: ban.expiresAt });

    const durationStr =
      duration === 'permanent' ? 'permanent' : `${Math.round(durationMs / 3600000)} hours`;

    return { banned: true, duration: durationStr };
  }

  /**
   * Check if IP is banned
   */
  async isIPBanned(ip: string): Promise<boolean> {
    const ban = this.bannedIPs.get(ip);
    if (!ban) return false;

    // Check if permanent
    if (ban.expiresAt === -1) return true;

    // Check if expired
    if (Date.now() >= ban.expiresAt) {
      this.bannedIPs.delete(ip);
      return false;
    }

    return true;
  }

  /**
   * Unban an IP address
   */
  async unbanIP(ip: string, reason: string = 'Manual unban'): Promise<boolean> {
    const ban = this.bannedIPs.get(ip);
    if (!ban) return false;

    this.bannedIPs.delete(ip);

    // Sync to Swarm
    if (this.config.enableSwarmSync) {
      await this.syncUnbanToSwarm(ip);
    }

    this.emit('ip_unbanned', { ip, reason });
    return true;
  }

  /**
   * Get banned IP info
   */
  getBannedIPInfo(ip: string): BannedIP | undefined {
    return this.bannedIPs.get(ip);
  }

  /**
   * Get all banned IPs
   */
  getAllBannedIPs(): BannedIP[] {
    return Array.from(this.bannedIPs.values());
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ATTACKER PROFILING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Update attacker profile
   */
  private updateAttackerProfile(ip: string, violations: SecurityViolation[]): void {
    const fingerprint = violations[violations.length - 1]?.fingerprint || ip;
    let profile = this.attackerProfiles.get(fingerprint);

    if (!profile) {
      profile = {
        fingerprint,
        knownIPs: [],
        firstSeen: Date.now(),
        lastSeen: Date.now(),
        totalViolations: 0,
        attackTypes: [],
        threatLevel: 'low',
        patterns: {
          avgTimeBetweenAttempts: 0,
          preferredEndpoints: [],
          userAgentPatterns: [],
          geoLocations: [],
        },
        isHoneyPotTarget: false,
      };
    }

    // Update profile
    if (!profile.knownIPs.includes(ip)) {
      profile.knownIPs.push(ip);
    }
    profile.lastSeen = Date.now();
    profile.totalViolations += violations.length;

    // Add attack types
    for (const v of violations) {
      if (!profile.attackTypes.includes(v.type)) {
        profile.attackTypes.push(v.type);
      }
    }

    // Calculate threat level
    profile.threatLevel = this.calculateThreatLevel(violations);

    // Mark as HoneyPot target if critical
    if (profile.threatLevel === 'critical') {
      profile.isHoneyPotTarget = true;
    }

    this.attackerProfiles.set(fingerprint, profile);
    this.emit('profile_updated', { fingerprint, profile });
  }

  /**
   * Get attacker profile
   */
  getAttackerProfile(ip: string): AttackerProfile | undefined {
    // Find by IP in known IPs
    for (const profile of this.attackerProfiles.values()) {
      if (profile.knownIPs.includes(ip)) {
        return profile;
      }
    }
    return undefined;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SWARM SYNCHRONIZATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Sync ban to Swarm
   */
  private async syncBanToSwarm(ban: BannedIP): Promise<void> {
    const message: SwarmSyncMessage = {
      type: 'ban',
      nodeId: this.config.nodeId,
      timestamp: Date.now(),
      payload: ban,
      signature: this.signMessage(ban),
    };

    this.emit('swarm_sync', { type: 'ban', ip: ban.ip });
    ban.swarmSynced = true;

    // In production, this would broadcast to other Swarm nodes
    // For now, we emit an event that can be handled by the orchestrator
  }

  /**
   * Sync unban to Swarm
   */
  private async syncUnbanToSwarm(ip: string): Promise<void> {
    const message: SwarmSyncMessage = {
      type: 'unban',
      nodeId: this.config.nodeId,
      timestamp: Date.now(),
      payload: { ip },
      signature: this.signMessage({ ip }),
    };

    this.emit('swarm_sync', { type: 'unban', ip });
  }

  /**
   * Receive ban from Swarm peer
   */
  async receiveBanFromSwarm(message: SwarmSyncMessage): Promise<void> {
    if (!this.verifyMessage(message.payload, message.signature)) {
      this.emit('swarm_invalid_signature', { nodeId: message.nodeId });
      return;
    }

    const ban = message.payload as BannedIP;
    ban.swarmSynced = true;
    this.bannedIPs.set(ban.ip, ban);

    this.emit('swarm_ban_received', { ip: ban.ip, fromNode: message.nodeId });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // HELPER METHODS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Classify attack type
   */
  private classifyAttack(reason: string, metadata: Record<string, unknown>): AttackType {
    const reasonLower = reason.toLowerCase();

    if (reasonLower.includes('invalid') && reasonLower.includes('key')) {
      return 'brute_force';
    }
    if (reasonLower.includes('rate') || reasonLower.includes('limit')) {
      return 'rate_abuse';
    }
    if (reasonLower.includes('injection') || reasonLower.includes('sql')) {
      return 'injection';
    }
    if (metadata.isKnownLeakedCredential) {
      return 'credential_stuffing';
    }

    return 'unknown';
  }

  /**
   * Calculate threat level
   */
  private calculateThreatLevel(violations: SecurityViolation[]): ThreatLevel {
    const count = violations.length;
    const hasInjection = violations.some((v) => v.type === 'injection');
    const hasCredentialStuffing = violations.some((v) => v.type === 'credential_stuffing');

    if (hasInjection || count >= 20) return 'critical';
    if (hasCredentialStuffing || count >= 10) return 'high';
    if (count >= 5) return 'medium';
    return 'low';
  }

  /**
   * Generate fingerprint from IP and metadata
   */
  private generateFingerprint(ip: string, metadata: Record<string, unknown>): string {
    const data = JSON.stringify({ ip, userAgent: metadata.userAgent, ...metadata });
    return crypto.createHash('sha256').update(data).digest('hex').substring(0, 16);
  }

  /**
   * Sign message for Swarm
   */
  private signMessage(payload: unknown): string {
    const data = JSON.stringify(payload);
    return crypto.createHmac('sha256', this.config.swarmSecret).update(data).digest('hex');
  }

  /**
   * Verify message signature
   */
  private verifyMessage(payload: unknown, signature: string): boolean {
    const expected = this.signMessage(payload);
    return crypto.timingSafeEqual(Buffer.from(expected), Buffer.from(signature));
  }

  /**
   * Send alert
   */
  private async sendAlert(type: string, data: Record<string, unknown>): Promise<void> {
    if (!this.config.alertWebhook) return;

    try {
      // In production, this would send to webhook
      this.emit('alert_sent', { type, data });
    } catch (e) {
      this.emit('alert_failed', { type, error: e });
    }
  }

  /**
   * Start cleanup timer
   */
  private startCleanupTimer(): void {
    setInterval(() => {
      const now = Date.now();
      const windowStart = now - this.config.attemptWindowMs;

      // Clean old violations
      for (const [ip, violations] of this.violationHistory) {
        const recent = violations.filter((v) => v.timestamp >= windowStart);
        if (recent.length === 0) {
          this.violationHistory.delete(ip);
        } else {
          this.violationHistory.set(ip, recent);
        }
      }

      // Clean expired bans
      for (const [ip, ban] of this.bannedIPs) {
        if (ban.expiresAt !== -1 && now >= ban.expiresAt) {
          this.bannedIPs.delete(ip);
          this.emit('ban_expired', { ip });
        }
      }
    }, 60000); // Every minute
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PUBLIC GETTERS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get fortress statistics
   */
  getStats(): {
    bannedIPs: number;
    totalViolations: number;
    attackerProfiles: number;
    swarmPeers: number;
    threatBreakdown: Record<ThreatLevel, number>;
  } {
    const threatBreakdown: Record<ThreatLevel, number> = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0,
    };

    for (const ban of this.bannedIPs.values()) {
      threatBreakdown[ban.threatLevel]++;
    }

    return {
      bannedIPs: this.bannedIPs.size,
      totalViolations: Array.from(this.violationHistory.values()).reduce(
        (sum, v) => sum + v.length,
        0
      ),
      attackerProfiles: this.attackerProfiles.size,
      swarmPeers: this.swarmPeers.size,
      threatBreakdown,
    };
  }

  /**
   * Check if initialized
   */
  isReady(): boolean {
    return this.isInitialized;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FATALITY HOOK ADAPTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Create a Fatality Hook adapter for ClientOrchestrator
 */
export function createFatalityHook(fortress: FortressIntegration) {
  return {
    async reportInvalidAttempt(ip: string, keyId: string, reason: string): Promise<void> {
      await fortress.reportInvalidAttempt(ip, keyId, reason);
    },
    async banIP(ip: string, reason: string, duration?: number): Promise<void> {
      await fortress.banIP(ip, reason, duration);
    },
    async isIPBanned(ip: string): Promise<boolean> {
      return fortress.isIPBanned(ip);
    },
    async getAttackerProfile(ip: string): Promise<unknown> {
      return fortress.getAttackerProfile(ip);
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FACTORY & EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let fortressInstance: FortressIntegration | null = null;

/**
 * Get singleton FortressIntegration instance
 */
export function getFortressIntegration(config?: Partial<FortressConfig>): FortressIntegration {
  if (!fortressInstance) {
    fortressInstance = new FortressIntegration(config);
  }
  return fortressInstance;
}

/**
 * Create new FortressIntegration instance
 */
export function createFortressIntegration(config?: Partial<FortressConfig>): FortressIntegration {
  return new FortressIntegration(config);
}

export default FortressIntegration;
