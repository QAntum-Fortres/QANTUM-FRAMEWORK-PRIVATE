/**
 * ╔═══════════════════════════════════════════════════════════════════════════╗
 * ║  QAntum Prime v28.0 - LIVE WALLET MANAGER                                 ║
 * ║  "Fortress Protocol" - 256-bit AES Encrypted Key Management               ║
 * ║                                                                           ║
 * ║  ⚠️  WARNING: THIS MODULE HANDLES REAL MONEY                              ║
 * ║  ⚠️  NEVER share your master password or API keys                         ║
 * ║  ⚠️  Test thoroughly in PAPER mode before going LIVE                      ║
 * ╚═══════════════════════════════════════════════════════════════════════════╝
 */

import { EventEmitter } from 'events';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

// ═══════════════════════════════════════════════════════════════════════════
// TYPES & INTERFACES
// ═══════════════════════════════════════════════════════════════════════════

export interface ExchangeCredentials {
    exchange: string;
    apiKey: string;
    apiSecret: string;
    passphrase?: string;
    subAccountId?: string;
    permissions: ('read' | 'trade' | 'withdraw')[];
    createdAt: number;
    lastUsed: number;
}

export interface WalletConfig {
    id: string;
    name: string;
    exchange: string;
    type: 'spot' | 'futures' | 'margin';
    isActive: boolean;
    dailyLimit: number;
    maxPositionSize: number;
    allowedSymbols: string[];
}

export interface WalletBalance {
    exchange: string;
    asset: string;
    free: number;
    locked: number;
    total: number;
    usdValue: number;
    lastUpdated: number;
}

export interface WithdrawalTarget {
    id: string;
    name: string;
    address: string;
    network: string;
    isWhitelisted: boolean;
    addedAt: number;
}

export interface FortressConfig {
    masterPasswordHash: string;
    encryptionAlgorithm: 'aes-256-gcm';
    keyDerivation: 'pbkdf2';
    iterations: number;
    saltLength: number;
    ivLength: number;
    tagLength: number;
    vaultPath: string;
    autoLockMinutes: number;
    maxFailedAttempts: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// FORTRESS ENCRYPTION ENGINE
// ═══════════════════════════════════════════════════════════════════════════

class FortressEncryption {
    private readonly algorithm = 'aes-256-gcm';
    private readonly keyLength = 32; // 256 bits
    private readonly ivLength = 16;
    private readonly saltLength = 32;
    private readonly tagLength = 16;
    private readonly iterations = 100000;

    private deriveKey(password: string, salt: Buffer): Buffer {
        return crypto.pbkdf2Sync(
            password,
            salt,
            this.iterations,
            this.keyLength,
            'sha512'
        );
    }

    public encrypt(plaintext: string, password: string): string {
        const salt = crypto.randomBytes(this.saltLength);
        const iv = crypto.randomBytes(this.ivLength);
        const key = this.deriveKey(password, salt);

        const cipher = crypto.createCipheriv(this.algorithm, key, iv, {
            authTagLength: this.tagLength,
        });

        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        const authTag = cipher.getAuthTag();

        return [
            salt.toString('hex'),
            iv.toString('hex'),
            authTag.toString('hex'),
            encrypted,
        ].join(':');
    }

    public decrypt(encryptedData: string, password: string): string {
        const parts = encryptedData.split(':');
        if (parts.length !== 4) {
            throw new Error('Invalid encrypted data format');
        }

        const [saltHex, ivHex, authTagHex, ciphertext] = parts;
        const salt = Buffer.from(saltHex, 'hex');
        const iv = Buffer.from(ivHex, 'hex');
        const authTag = Buffer.from(authTagHex, 'hex');
        const key = this.deriveKey(password, salt);

        const decipher = crypto.createDecipheriv(this.algorithm, key, iv, {
            authTagLength: this.tagLength,
        });
        decipher.setAuthTag(authTag);

        let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
        decrypted += decipher.final('utf8');

        return decrypted;
    }

    public hashPassword(password: string): string {
        const salt = crypto.randomBytes(32);
        const hash = crypto.pbkdf2Sync(password, salt, this.iterations, 64, 'sha512');
        return `${salt.toString('hex')}:${hash.toString('hex')}`;
    }

    public verifyPassword(password: string, storedHash: string): boolean {
        const [saltHex, hashHex] = storedHash.split(':');
        const salt = Buffer.from(saltHex, 'hex');
        const computedHash = crypto.pbkdf2Sync(password, salt, this.iterations, 64, 'sha512');
        return computedHash.toString('hex') === hashHex;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// LIVE WALLET MANAGER
// ═══════════════════════════════════════════════════════════════════════════

export class LiveWalletManager extends EventEmitter {
    private fortress: FortressEncryption;
    private isUnlocked: boolean = false;
    private masterPassword: string | null = null;
    private credentials: Map<string, ExchangeCredentials> = new Map();
    private wallets: Map<string, WalletConfig> = new Map();
    private balances: Map<string, WalletBalance[]> = new Map();
    private withdrawalTargets: Map<string, WithdrawalTarget> = new Map();

    private failedAttempts: number = 0;
    private lockoutUntil: number = 0;
    private autoLockTimeout: NodeJS.Timeout | null = null;
    private lastActivity: number = Date.now();

    private readonly vaultPath: string;
    private readonly maxFailedAttempts = 5;
    private readonly lockoutDurationMs = 300000; // 5 minutes
    private readonly autoLockMs = 600000; // 10 minutes

    constructor(vaultPath: string = './data/fortress') {
        super();
        this.fortress = new FortressEncryption();
        this.vaultPath = vaultPath;

        if (!fs.existsSync(vaultPath)) {
            fs.mkdirSync(vaultPath, { recursive: true });
        }
    }

    public initializeVault(masterPassword: string): boolean {
        if (masterPassword.length < 12) return false;

        const passwordHash = this.fortress.hashPassword(masterPassword);

        const config: FortressConfig = {
            masterPasswordHash: passwordHash,
            encryptionAlgorithm: 'aes-256-gcm',
            keyDerivation: 'pbkdf2',
            iterations: 100000,
            saltLength: 32,
            ivLength: 16,
            tagLength: 16,
            vaultPath: this.vaultPath,
            autoLockMinutes: 10,
            maxFailedAttempts: 5,
        };

        fs.writeFileSync(
            path.join(this.vaultPath, 'config.json'),
            JSON.stringify(config, null, 2)
        );

        return true;
    }

    public unlock(masterPassword: string): boolean {
        if (Date.now() < this.lockoutUntil) return false;

        const configPath = path.join(this.vaultPath, 'config.json');
        if (!fs.existsSync(configPath)) return false;

        const config: FortressConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));

        if (!this.fortress.verifyPassword(masterPassword, config.masterPasswordHash)) {
            this.failedAttempts++;
            if (this.failedAttempts >= this.maxFailedAttempts) {
                this.lockoutUntil = Date.now() + this.lockoutDurationMs;
            }
            return false;
        }

        this.failedAttempts = 0;
        this.isUnlocked = true;
        this.masterPassword = masterPassword;
        this.lastActivity = Date.now();

        this.loadCredentials();
        this.startAutoLockTimer();

        return true;
    }

    public lock(): void {
        this.isUnlocked = false;
        this.masterPassword = null;
        this.credentials.clear();

        if (this.autoLockTimeout) {
            clearTimeout(this.autoLockTimeout);
            this.autoLockTimeout = null;
        }
    }

    private startAutoLockTimer(): void {
        if (this.autoLockTimeout) {
            clearTimeout(this.autoLockTimeout);
        }

        this.autoLockTimeout = setTimeout(() => {
            if (Date.now() - this.lastActivity > this.autoLockMs) {
                this.lock();
            } else {
                this.startAutoLockTimer();
            }
        }, 60000);
    }

    private touchActivity(): void {
        this.lastActivity = Date.now();
    }

    public addCredentials(creds: Omit<ExchangeCredentials, 'createdAt' | 'lastUsed'>): boolean {
        if (!this.isUnlocked || !this.masterPassword) return false;

        this.touchActivity();

        const credentials: ExchangeCredentials = {
            ...creds,
            createdAt: Date.now(),
            lastUsed: 0,
        };

        this.credentials.set(creds.exchange, credentials);
        this.saveCredentials();
        return true;
    }

    public getCredentials(exchange: string): ExchangeCredentials | null {
        if (!this.isUnlocked) return null;
        this.touchActivity();
        const creds = this.credentials.get(exchange);
        if (creds) creds.lastUsed = Date.now();
        return creds || null;
    }

    private loadCredentials(): void {
        const credsPath = path.join(this.vaultPath, 'credentials.enc');
        if (!fs.existsSync(credsPath)) return;

        try {
            const encrypted = fs.readFileSync(credsPath, 'utf8');
            const decrypted = this.fortress.decrypt(encrypted, this.masterPassword!);
            const credsArray: ExchangeCredentials[] = JSON.parse(decrypted);

            this.credentials.clear();
            for (const cred of credsArray) {
                this.credentials.set(cred.exchange, cred);
            }
        } catch (error) {
            console.error('[Fortress] ❌ Failed to load credentials:', error);
        }
    }

    private saveCredentials(): void {
        if (!this.masterPassword) return;
        const credsArray = Array.from(this.credentials.values());
        const plaintext = JSON.stringify(credsArray);
        const encrypted = this.fortress.encrypt(plaintext, this.masterPassword);
        fs.writeFileSync(path.join(this.vaultPath, 'credentials.enc'), encrypted);
    }

    public updateBalance(exchange: string, balances: WalletBalance[]): void {
        this.balances.set(exchange, balances);
    }

    public getBalance(exchange: string): WalletBalance[] {
        return this.balances.get(exchange) || [];
    }
}

export const liveWalletManager = new LiveWalletManager('./data/fortress');
export default LiveWalletManager;
