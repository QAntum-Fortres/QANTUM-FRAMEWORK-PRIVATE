<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QAntum Prime - Antigravity Dashboard</title>
    <!-- âš¡ Bolt Optimization: Switching to Canvas for high-performance rendering of 1200+ nodes -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #0f0;
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #0f0;
            min-width: 200px;
        }

        .stat-item {
            margin: 5px 0;
            font-size: 12px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 2000;
            font-size: 11px;
            max-width: 300px;
            color: #0f0;
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="header">
            <h1>ðŸŒŒ ANTIGRAVITY DASHBOARD</h1>
            <p>QAntum Prime - Live Module Network</p>
            <p style="font-size: 0.8em; color: #888;">âš¡ Render: HTML5 Canvas (Bolt Optimized)</p>
        </div>
        <div class="stats">
            <div class="stat-item">Total Modules: <span id="total-modules">0</span></div>
            <div class="stat-item">ðŸŸ¢ ALIVE: <span id="alive-count">0</span></div>
            <div class="stat-item">ðŸŸ¡ UNKNOWN: <span id="unknown-count">0</span></div>
            <div class="stat-item">Core: <span id="core-count">0</span></div>
            <div class="stat-item">Security: <span id="security-count">0</span></div>
            <div class="stat-item">Products: <span id="product-count">0</span></div>
            <div class="stat-item">FPS: <span id="fps-counter">0</span></div>
        </div>
        <canvas id="galaxy"></canvas>
        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        const canvas = document.getElementById('galaxy');
        const context = canvas.getContext('2d');
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Handle high DPI displays
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        context.scale(dpr, dpr);

        const tooltip = d3.select('#tooltip');
        let transform = d3.zoomIdentity;

        // FPS Counter
        let lastTime = 0;
        let frameCount = 0;
        const fpsElement = document.getElementById('fps-counter');

        // Load modules from API
        fetch('/api/modules')
            .then(res => res.json())
            .then(data => {
                if (data.length === 0) {
                    console.warn("No modules found via API, trying fallback...");
                    return fetch('/mega-map.json').then(r => r.json());
                }
                return data;
            })
            .then(data => {
                initGalaxy(data);
                updateStats(data);
            })
            .catch(err => {
                console.error("Failed to load map data:", err);
                // Fallback demo data if fetch fails
                const demoData = Array.from({ length: 100 }, (_, i) => ({
                    id: `demo-${i}`,
                    type: ['Core', 'Security', 'Product'][i % 3],
                    status: 'ðŸŸ¢ ALIVE',
                    exports: [],
                    loc: Math.random() * 1000,
                    path: '/src/demo'
                }));
                // initGalaxy(demoData); // Uncomment if needed for offline debugging
            });

        function updateStats(modules) {
            document.getElementById('total-modules').textContent = modules.length;
            document.getElementById('alive-count').textContent = modules.filter(m => m.status === 'ðŸŸ¢ ALIVE').length;
            document.getElementById('unknown-count').textContent = modules.filter(m => m.status === 'ðŸŸ¡ UNKNOWN').length;
            document.getElementById('core-count').textContent = modules.filter(m => m.type === 'Core').length;
            document.getElementById('security-count').textContent = modules.filter(m => m.type === 'Security').length;
            document.getElementById('product-count').textContent = modules.filter(m => m.type === 'Product').length;
        }

        function initGalaxy(modules) {
            const nodes = modules.map(m => ({
                id: m.id,
                type: m.type || 'Unknown',
                status: m.status || 'ðŸŸ¡ UNKNOWN',
                exports: m.exports || [],
                loc: m.loc || 0,
                path: m.path,
                x: Math.random() * width,
                y: Math.random() * height,
                r: Math.min(3 + (m.loc || 0) / 100, 10)
            }));

            // Create links based on types to form clusters
            const links = [];
            const typeGroups = {};
            nodes.forEach(n => {
                if (!typeGroups[n.type]) typeGroups[n.type] = [];
                typeGroups[n.type].push(n);
            });

            // Link nodes within same type
            Object.values(typeGroups).forEach(group => {
                for (let i = 0; i < group.length; i++) {
                    // Connect to 2 nearest neighbors of same type
                    const neighbors = 2;
                    for (let j = 1; j <= neighbors; j++) {
                        if (i + j < group.length) {
                            links.push({ source: group[i].id, target: group[i+j].id });
                        }
                    }
                }
            });

            // Force Simulation
            // âš¡ Bolt Optimization: alphaDecay(0.04) stabilizes 1200+ nodes faster.
            // âš¡ Bolt Optimization: iterations(1) reduces physics cost per tick.
            const simulation = d3.forceSimulation(nodes)
                .alphaDecay(0.04) // âš¡ Bolt Optimization: Faster stabilization for 1200+ nodes
                .force('link', d3.forceLink(links).id(d => d.id).distance(50).strength(0.2))
                .force('charge', d3.forceManyBody().strength(-30))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collide', d3.forceCollide().radius(d => d.r + 2).iterations(1)); // âš¡ Bolt Optimization: Reduced overhead

            // Drag behavior
            d3.select(canvas)
                .call(d3.drag()
                    .subject(dragSubject)
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded))
                .call(d3.zoom()
                    .scaleExtent([0.1, 8])
                    .on("zoom", zoomed));

            function zoomed(event) {
                transform = event.transform;
                render();
            }

            function dragSubject(event) {
                const x = transform.invertX(event.x);
                const y = transform.invertY(event.y);

                // Find nearest node
                let subject = null;
                let minDist = 20;

                for (const node of nodes) {
                    const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                    if (dist < minDist && dist < node.r + 5) {
                        minDist = dist;
                        subject = node;
                    }
                }
                return subject;
            }

            function dragStarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragEnded(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            // Mouse Move for Tooltip
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = transform.invertX(e.clientX - rect.left);
                const y = transform.invertY(e.clientY - rect.top);

                const node = nodes.find(n => {
                    const dist = Math.sqrt((x - n.x) ** 2 + (y - n.y) ** 2);
                    return dist < n.r + 2;
                });

                if (node) {
                    tooltip.style('display', 'block')
                        .html(`
                            <strong>${node.id}</strong><br/>
                            <span style="color: #aaa">${node.type}</span><br/>
                            ${node.status}<br/>
                            LOC: ${node.loc}<br/>
                            <small>${node.path ? node.path.split('/').pop() : ''}</small>
                        `)
                        .style('left', (e.clientX + 10) + 'px')
                        .style('top', (e.clientY - 10) + 'px');
                    canvas.style.cursor = 'pointer';
                } else {
                    tooltip.style('display', 'none');
                    canvas.style.cursor = 'default';
                }
            });

            // Render Loop
            simulation.on("tick", () => {
                // Throttle rendering if needed, but requestAnimationFrame usually handles it
                render();

                // FPS Calculation
                const now = performance.now();
                frameCount++;
                if (now - lastTime >= 1000) {
                    fpsElement.textContent = frameCount;
                    frameCount = 0;
                    lastTime = now;
                }
            });

            function render() {
                context.save();
                context.clearRect(0, 0, width, height);
                context.translate(transform.x, transform.y);
                context.scale(transform.k, transform.k);

                // Draw Links
                context.strokeStyle = "rgba(0, 255, 0, 0.2)";
                context.lineWidth = 1;
                context.beginPath();
                links.forEach(link => {
                    context.moveTo(link.source.x, link.source.y);
                    context.lineTo(link.target.x, link.target.y);
                });
                context.stroke();

                // Draw Nodes
                nodes.forEach(node => {
                    context.beginPath();
                    context.arc(node.x, node.y, node.r, 0, 2 * Math.PI);

                    if (node.status === 'ðŸŸ¢ ALIVE') context.fillStyle = "#0f0";
                    else if (node.status === 'ðŸ”´ DEAD') context.fillStyle = "#f00";
                    else context.fillStyle = "#ff0";

                    context.fill();

                    // Node border based on type
                    if (node.type === 'Core') {
                        context.strokeStyle = "#00f";
                        context.lineWidth = 2;
                        context.stroke();
                    } else if (node.type === 'Security') {
                        context.strokeStyle = "#f0f";
                        context.lineWidth = 2;
                        context.stroke();
                    }
                });

                context.restore();
            }
        }
    </script>
</body>

</html>